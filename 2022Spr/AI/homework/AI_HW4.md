# AI_HW4

PB19111713钟颖康



### 5.9 本题以井字棋（圈与十字游戏）为例练习博弈中的基本概念。定义$X_n$为恰好有$n$个$X$而没有$O$的行、列或者对角线的数目。同样$O_n$为正好有$n$个$O$的行、列或者对角线的数目。效用函数给$X_3=1$的棋局$+1$，给$O_3=1$的棋局$−1$。所有其他终止状态效用值为$0$。对于非终止状态，使用线性的评估函数定义为$Eval(s)=3X_2(s)+X_1(s)−(3O_2(s)+O_1(s))$。

#### a. 估算可能的井字棋局数。

至多有$9!$种局面。考虑到提前结束，故只有765种。

#### b. 考虑对称性，给出从空棋盘开始的深度为2的完整博弈树(即，在棋盘上一个$X$一个$O$的棋局)。

![](figs\hw4_1_b.jpg)

#### c. 标出深度为2的棋局的评估函数值。

![](figs\hw4_1_c.jpg)

#### d. 使用极小极大算法标出深度为1和0的棋局的倒推值,并根据这些值选出最佳的起始行棋。

![](figs\hw4_1_d.jpg)

#### e. 假设结点按对$α−β$剪枝的最优顺序生成，圈出使用$α−β$剪枝将被剪掉的深度为2的结点。

若按最优顺序生成，则剪枝如下图所示：

![](figs\hw4_1_e.jpg)



### 5.8 考虑**图5.17**中描述的两人游戏。

#### a. 根据如下约定画出完整博弈树:

- 每个状态用$(s_A,s_B)$表示，其中$s_A$和$s_B$表示棋子的位置。
- 每个终止状态用方框画出，用圆圈写出它的博弈值。
- 把循环状态（在到根结点的路径上已经出现过的状态）画上双层方框。由于不清楚他们的值，在圆圈里标记一个“? ”。

![](figs\hw4_2_a.jpg)

#### b. 给出每个结点倒推的极小极大值（也标记在圆圈里)。解释怎样处理“?”值和为什么这么处理。

![](figs\hw4_2_b.jpg)

处理“？”值：

- 若子节点只有“？”，显然只能选择“？”
- 若子节点为+1和“？”，显然选择+1的路径一定能赢，即max(+1,?)=+1，min(+1,?)=?
- 若子节点为-1和“？”，显然选择-1的路径一定不能赢，而选择“？”仍有可能赢，即max(-1,?)=?，min(-1,?)=-1



#### c. 解释标准的极小极大算法为什么在这棵博弈树中会失败，简要说明你将如何修正它，在**（b）**的图上画出你的答案。你修正后的算法对于所有包含循环的游戏都能给出最优决策吗?

- 标准极小极大算法会陷入死循环。
- 将已经访问过的状态记录下来，对每一个新节点先检查是否是已经处理过的节点，若不是则正常处理，若是则标记为“？”并按照**b.**中的方法处理。
- 不能。因为这棵树比较简单，只有+1、-1和“？”，但是在其它游戏中“？”或许难以衡量大小，即难以通过比较得到min与max。



#### d. 这个4-方格游戏可以推广到$n$个方格，其中$n>2$。证明如果$n$是偶数$A$一定能赢，而$n$是奇数则$A$一定会输。

以下采用数学归纳法：

1. 分析易知，$n=4$时$A$有策略能保证一定能赢，而$n=3$时$A$一定会输。
2. 假设$n\leq2k$时，$n$为偶数则$A$一定能赢，$n$为奇数则$A$一定会输。
3. 考虑$n=2k+1$的情况，显然$A$先手第一步只有一种走法，此时相当于$A$后手且$n$为偶数，故$A$一定会输。
4. 考虑$n=2k+2$的情况，显然$A$和对手的第一步均只有一种走法，此时相当于$A$先手且$n$为偶数，故$A$一定能赢。

综上，原命题成立。



### 5.13 请给出$α−β$剪枝正确性的形式化证明。要做到这一点需考虑**图5.18**。问题为是否要剪掉结点$n_j$,它是一个**MAX**结点，是$n_1$的一个后代。基本的思路是当且仅当$n_1$的极小极大值可以被证明独立于$n_j$的值时，会发生剪枝。

#### a. $n_1$的值是所有后代结点的最小值: $n_1=min(n_2,n_{21},...,n_{2\ b_2})$请为$n_2$找到类似的表达式，以得到用$n_j$表示的$n_1$的表达式。

对于$n_2$​：
$$
n_2=max(n_3,n_{31},...,n_{3\ b_3})
$$
同理可得$n_3,n_4,...,n_{j-1}$，

故反复迭代直到$n_{j-1}=max(n_j,n_{j1},...,n_{j\ b_j})$可得
$$
n_1=min(max(...max(n_j,n_{j1},...,n_{j\ b_j}),...,n_{31},...,n_{3\ b_3}),n_{21},...,n_{2\ b_2})
$$


#### b. 深度为$i$的结点$n_i$的极小极大值已知，$l_i$是在结点$n_i$左侧结点的极小值（或者极大值)。同样，$r_i$是在$n_i$右侧的未探索过的结点的极小值(或者极大值)。用$l_i$和$r_i$的值重写$n_1$的表达式。

$$
n_1=min(l_2,max(l_3,n_3,r_3),r_2)
$$

和**a.**同理，反复迭代直到$n_{j-1}=max(l_j,n_j,r_j)$



#### c. 现在重新形式化表达式，来说明为了向$n_1$施加影响，$n_j$不能超出由$l_i$值得到的某特定界限。

- 对于$min()$中的$l_i$，为了使$n_j$有效，可知$n_j<l_i$
- 对于$max()$中的$l_i$，为了使$n_j$有效，可知$n_j>l_i$
- 根据题意，$n_j$是一个MAX结点，故$max(l_3,l_5,...,l_{j-1})<n_j<min(l_2,l_4,...,l_j)$



#### d. 假设$n_j$是**MIN**结点的情况，请重复上面的过程。

同理，
$$
n_1=min(l_2,max(l_3,n_3,r_3),r_2)
$$
反复迭代直到$n_{j-1}=min(l_j,n_j,r_j)$

- 对于$min()$中的$l_i$，为了使$n_j$有效，可知$n_j<l_i$
- 对于$max()$中的$l_i$，为了使$n_j$有效，可知$n_j>l_i$
- 根据题意，$n_j$是一个MAX结点，故$max(l_3,l_5,...,l_j)<n_j<min(l_2,l_4,...,l_{j-1})$

